# 최소비용 신장트리(MST)

## 요약

>신장 트리를 구성하는 간선들의 가중치의 합이 최소가 되는 트리를 최소 신장 트리라 하며 , 대표적으로 크루스칼 알고리즘, 프림 알고리즘이 있다.
>
>크루스칼 알고리즘은 **간선 선택 기반 알고리즘**으로, 가중치가 최소인 간선을 하나씩 선택해서 MST를 만드는 알고리즘이다. 
>
>프림 알고리즘은 정점 선택 기반 알고리즘으로, 하나의 정점에서 연결된 간선들 중 가중치가 최소인 간선을 가진 정점을 하나씩 선택해서 MST를 만드는 알고리즘이다.

## 정의

- 신장 트리

  N개의 정점으로 이루어진 무향 그래프에서 N개의 정점과 N-1개의 간선으로 이루어진 트리

- **최소 신장 트리 (Minimum Spanning Tree)**

  무향 가중치 그래프에서 신장 트리를 구성하는 **간선들의 가중치의 합이 최소**인 신장 트리<br/>EX) 크루스칼 알고리즘, 프림 알고리즘

## 크루스칼 알고리즘

- 매 차례마다 **가중치가 최소인 간선을 선택**하면서 MST를 만드는 알고리즘
  1. 간선을 **오름차순으로 정렬**하여 선택한다.
  2. 사이클이 생성되지 않게 매번 **사이클 생성 여부를 판단**하면서 가중치가 가장 낮은 간선을 선택한다.
     - 사이클이란 A, B, C 정점이 있을 때 A-B, B-C, A-C로 그래프가 서로 연결되어 있는 상태를 의미
  3. N-1개의 간선이 선택될 때까지 2번 과정 반복
- **서로소(union-find) 알고리즘**과 **그리디 알고리즘 방법** 이용

- 의사코드

  ```groovy
  MST-KRUSKAL(G, w)
  	FOR vertex v int G.V	//G.V: 그래프의 정점 집합
  		Make_Set(v)			//G.E: 그래프의 간섡 집합
  		
  	G.E에 포함된 간선들을 가중치 w에 의해 오름차순 정렬
  	
  	FOR 가중치가 가장 낮은 간선 (u, v) ∈ G.E 선택 (n-1개만큼)
  		IF Find_Set(u) != Find_Set(v) // 사이클 생성 여부 판단
  			A = A ∪ {(u, v)}
  			Union(u, v) 	// 간선 연결
  ```

- 시간복잡도
  - 사실상 정렬 알고리즘과 Union-Find 알고리즘의 합이기 때문에 정렬 알고리즘의 시간 복잡도와 동일하다고 판단 가능
  - 가중치순으로 정렬하는데 E * logE 만큼의 시간이 소요되었으므로<br/> **시간복잡도는 O(ElogE)**

## 프림 알고리즘

- **하나의 정점**에서 연결된 간선들 중에 하나씩 선택하면서 MST를 만들어 가는 방식

  1. 임의의 정점 하나 선택
  2. 선택한 정점과 인접하는 선택되지 않은 정점들 중 **가중치가 최소인 간선**으로 연결된 정점을 새로 선택
  3. 모든 정점이 선택될 때까지 2번 과정 반복

- 이미 선택된 정점을 다시 선택하지 않기 때문에, 사이클 생성 여부 판단하지 않음

- 의사코드

  ```groovy
  MST_PRIM(G, r)				//G: 그래프, r: 시작 정점
  	result = 0, cnt = 0;	//result: 신장트리 최소비용, cnt:처리한 정점수
  	FOR u in G.V
  		miniEdge[u] =  MAX_VALUE		// miniEdge[]: 각 정점기준으로 다른 정점과의 간선 중 최소비용
  	miniEdge[r] = 0						//시작 정점 r의 최소 비용 0처리
  	WHILE true
  		u = Extract_MIN( )				//방문하지 않은(최소신장트리에 포함되지 않는 정점) 최소비용 정점 찾기
  		visited[u] = true
  		result = result + miniEdge[u];	//비용 누적
  		if(++cnt == N) break;
  		FOR v in G.Adj[u] 				//u의 인접 정점들
  			IF visited[v] == false AND w(u, v) < miniEdge[v]	//u에서 v로의 비용이 v의 최소비용보다 작다면 갱신
  				miniEdge[v] = w(u, v)
  	return result
  end MST_PRIM
  ```

- 시간복잡도

  - 우선순위 큐를 어떻게 구현하느냐에 따라 다르지만 <br/>일반적으로 **binary heap**으로 구현했을 경우 **O(ElogV)**<br/>**unsorted arrary**로 구현헀을경우 **O(|V²|)**

## 크루스칼 vs 프림 알고리즘 차이점

**크루스칼 알고리즘**은 정렬을 반드시 동반하기 때문에 **간선의 개수가 증가**하먼 정렬 소요 시간이 증가한다.

> 즉, **크루스칼 알고리즘은 간선의 개수가 많지 않은 경우에 적합하며, 간선의 개수가 많을 때는 프림 알고리즘을 사용한다.**

