# 트랜잭션
## 목차
### 1. 트랜잭션 정의
## 2. Isolation Level
### 3. 동시성 제어(락 메커니즘)
### 4. 교착상태(Dead Lock)와 회복(Recovery)
  
  
# Isolation Level
## 요약
- 격리 수준 혹은 고립 수준이라고 함
- 동시에 여러 트랜잭션이 처리될 때, 트랜잭션끼리 얼마나 서로 고립되어있는지를 나타내는 것
- READ UNCOMMITTED, READ COMMITED, REPEATABLE READ, SERIALIZABLE 4가지가 있음
- 각 격리 수준에 따라 Dirty READ, NON-REPETABLE READ, Phantom Read가 발생

## Isolation Level이란(격리 수준)
- 트랜잭션이 얼마나 서로 고립되어있는지 나타내는 것
- 특정 트랜잭션이 다른 트랜잭션에 변경한 데이터를 볼 수 있도록 허용할지 말지를 결정

### 격리수준
	- 0레벨 : READ UNCOMMITTED
	- 1레벨 : READ COMMITED - (Oracle)
	- 2레벨 : REPEATABLE READ - (MySQL)
	- 3레벨 : SERIALIZABLE

- 아래로 내려갈수록 트랜잭션간 고립 정도가 높아지며, 동시성이 떨어짐(성능 떨어짐)

### 낮은 격리 수준에서 발생하는 3가지 현상(데이터 부정합 문제)
	 - Dirty Read : 아직 커밋되지 않은 수정 중인 데이터를 읽을 때 발생
	 - Non-Repetable Read : 하나의 트랜잭션에서 동일한 쿼리를 2번 실행했을 때, 그 사이에 다른 트랜잭션이 값을 수정 또는 삭제해 두 쿼리의 결과값이 다르게 나타나는 현상
	 - Phantom Read : 하나의 트랜잭션에서 동일한 쿼리를 2번 실행했을 때, 첫 번째 쿼리에서 없던 유령(Phantom) 레코드가 두 번째 쿼리에서 나타나는 현상
![데이터 부정합](https://github.com/leeejuhyeong/images/blob/main/no-study-no-future/Database/데이터%20부정합.jpg?raw=true)
  
  
## READ UNCOMMITTED
- 트랜잭션에서의 변경 내용이 COMMIT이나 ROLLBACK 여부에 상관없이 다른 트랜잭션에게 보여짐
- Dirty Read(더티 리드)가 일어남  
- RDBMS 표준에서 트랜잭션의 격리 수준으로 인정하지 않음
- 정합성에 문제가 많다!
> 정합성 : 데이터가 서로 모순이 없이 일관되게 일치해야 한다는 의미  
  
![Dirty Read](https://github.com/leeejuhyeong/images/blob/main/no-study-no-future/Database/Dirty%20Read.jpg?raw=true)]
  
  
## READ COMMITTED
- 트랜잭션이 시작되기 전에 커밋된 내용에 대해서만 조회할 수 있는 격리 수준
- Oracle에서 기본적으로 사용
- Dirty Read 방지!
![READ COMMITTED](https://github.com/leeejuhyeong/images/blob/main/no-study-no-future/Database/READ_COMMITTED.jpg?raw=true)
  
- Oracle의 방식, 이외의 DBMS는 베타 Lock으로 인해 읽기 대기(동시성 제어 추후 정리)
- NON-REPETABLE READ가 일어남
![Non-Repetable Read](https://github.com/leeejuhyeong/images/blob/main/no-study-no-future/Database/Non-Repetable%20Read.jpg?raw=true)
  
- 이름이 아닌 계좌의 금액 조회일 경우 금액의 총합이 다른 결과를 가져올 수 있다!
  

## REPETABLE READ
- 트랜잭션이 시작되기 전에 커밋된 내용에 대해서만 조회할 수 있는 격리 수준
- MySQL에서 기본적으로 사용, Oracle은 명시적으로 지원하진 않지만 (for update절을 이용해서 구현 가능) -> for update가 oracle에서만 쓸수있는 것은 아님
- NON-REPETABLE READ 방지!
![REPETABLE READ](https://github.com/leeejuhyeong/images/blob/main/no-study-no-future/Database/REPETABLE%20READ.jpg?raw=true)
  
- MVCC(Multi-Version Concurrency Control) 방식
	- 트랜잭션은 고유 트랜잭션 번호(순차적으로 증가)를 가짐
	- UNDO 영역에 백업된 모든 레코드는 변경이 일어난 트랜잭션 번호를 가짐
	- 변경되기 전 레코드를 UNDO 영역에 백업하고 실제 레코드를 변경
	- 자신의 트랜잭션 번호보다 낮은 트랜잭션 번호에서 변경된(+ 커밋된) 것만 봄
> 한 트랜잭션의 실행시간이 길어질수록 UNDO 영역의 데이터가 커져 서버 성능의 저하를 초래할 수도 있음  
> 동일 쿼리가 왜 동일한 트랜잭션 번호를 갖나? -> 같은 트랜잭션이기 때문에  
  
- Phantom Read 발생
![Phantom Read](https://github.com/leeejuhyeong/images/blob/main/no-study-no-future/Database/Phantom%20Read.jpg?raw=true)
  
- SELECT ~ FOR UPDATE
	- 데이터를 수정하기위해 SELECT 중이라는 의미
	- 특정 데이터에 대해 공유 Lock을 거는 기능(동시성 제어)
	- 그러나 데이터 변경이 막힌 것일 뿐 새로운 데이터 삽입(INSERT)은 가능하기 때문에 첫 번째 쿼리에는 없었던 Phantom Read가 발생
    
> Consistent read   
> - 트랜잭션 내부에서 non-locking read(기본 SELECT 구문) 실행할 때, 동시에 실행중인 다른 트랜잭션에서 데이터를 변경하더라도 특정 시점의 스냅샷(snapshot)을 이용하여 기존과 동일한 결과를 리턴할 수 있도록 해주는 기능  
> - MySQL은 이 기능을 사용하기 때문에 Phantom Read가 발생하지 않음  
  
  
## SERIALIZABLE
- 가장 단순하고 가장 엄격한 격리 수준
- 동시 처리 성능이 가장 떨어짐
- 한 트랜잭션에서 읽고 쓰는 레코드를 다른 트랜잭션에서는 절대 접근할 수 없음
- Phantom Read 방지!
- InnoDB의 경우 REPETABLE READ 격리 수준에서도 Phantom Read 문제가 발생하지 않기 때문에 사용하지 않는 편


## 출처
- [MySQL 격리 수준(Isolation Level)](https://transferhwang.tistory.com/513)
- [데이터베이스 Transaction & Lock : 네이버 블로그](https://m.blog.naver.com/good_ray/221943028058)
- [MySQL InnoDB Transaction Model 이해하기 | Knowledge Logger](https://www.letmecompile.com/mysql-innodb-transaction-model/)
- [MySQL의 Transaction Isolation Levels](https://jupiny.com/2018/11/30/mysql-transaction-isolation-levels/)